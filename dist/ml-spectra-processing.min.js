!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e=e||self).SpectraProcessing={})}(this,(function(e){"use strict";const t=Object.prototype.toString;var n,r=function(e){return t.call(e).endsWith("Array]")},l=function(e,t){return e(t={exports:{}},t.exports),t.exports}((function(e,t){function n(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!r(e.x)||!r(e.y))throw new Error("Points must be an object of x and y arrays");if(e.x.length!==e.y.length)throw new Error("The x and y arrays mush have the same length")}function l(e,t){let n=0,r=e.length-1,l=0;for(;r-n>1;)if(e[l=n+(r-n>>1)]<t)n=l;else{if(!(e[l]>t))return l;r=l}return n<e.length-1?Math.abs(t-e[n])<Math.abs(e[n+1]-t)?n:n+1:n}function o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{fromIndex:n,toIndex:r,from:o,to:i}=t;return void 0===n&&(n=void 0!==o?l(e,o):0),void 0===r&&(r=void 0!==i?l(e,i):e.length-1),{fromIndex:n,toIndex:r}}function i(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{target:n,targetIndex:r}=t;return void 0===r?void 0!==n?l(e,n):0:r}Object.defineProperty(t,"__esModule",{value:!0});const s={check:n,integral:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{reverse:r=!1}=t;n(e);const{x:l,y:i}=e;if(l.length<2)return 0;const{fromIndex:s,toIndex:f}=o(l,t);let h,a=0;if(r){h={x:[l[f]],y:[0]};for(let e=f;e>s;e--)a+=(l[e]-l[e-1])*(i[e-1]+i[e])/2,h.x.push(l[e-1]),h.y.push(a);h.x.reverse(),h.y.reverse()}else{h={x:[l[s]],y:[0]};for(let e=s;e<f;e++)a+=(l[e+1]-l[e])*(i[e+1]+i[e])/2,h.x.push(l[e+1]),h.y.push(a)}return h},integration:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(e);const{x:r,y:l}=e;if(r.length<2)return 0;const{fromIndex:i,toIndex:s}=o(r,t);let f=0;for(let e=i;e<s;e++)f+=(r[e+1]-r[e])*(l[e+1]+l[e])/2;return f},maxY:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(e);const{x:r,y:l}=e;if(r.length<2)return 0;const{fromIndex:i,toIndex:s}=o(r,t);let f=l[i];for(let e=i;e<=s;e++)l[e]>f&&(f=l[e]);return f},maximaY:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};n(e);const{x:t,y:r}=e;if(t.length<3)return[];let l=[],o=-1;for(let e=1;e<t.length-1;e++)if(r[e-1]<r[e]&&r[e+1]<r[e])l.push({x:t[e],y:r[e],index:e});else if(r[e-1]<r[e]&&r[e+1]===r[e])o=e;else if(r[e-1]===r[e]&&r[e+1]<r[e]){let n=(e+o)/2>>0;l.push({x:t[n],y:r[n],index:n})}return l},maxYPoint:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(e);const{x:r,y:l}=e;if(r.length<2)return 0;const{fromIndex:i,toIndex:s}=o(r,t);let f={x:r[i],y:l[i]};for(let e=i;e<=s;e++)l[e]>f.y&&(f={x:r[e],y:l[e]});return f},minimaY:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};n(e);const{x:t,y:r}=e;if(t.length<3)return[];let l=[],o=-1;for(let e=1;e<t.length-1;e++)if(r[e-1]>r[e]&&r[e+1]>r[e])l.push({x:t[e],y:r[e],index:e});else if(r[e-1]>r[e]&&r[e+1]===r[e])o=e;else if(r[e-1]===r[e]&&r[e+1]>r[e]){let n=(e+o)/2>>0;l.push({x:t[n],y:r[n],index:n})}return l},minYPoint:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(e);const{x:r,y:l}=e;if(r.length<2)return 0;const{fromIndex:i,toIndex:s}=o(r,t);let f={x:r[i],y:l[i]};for(let e=i;e<=s;e++)l[e]<f.y&&(f={x:r[e],y:l[e]});return f},reduce:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{from:r=e[0],to:o=e[e.length-1],nbPoints:i=4e3}=n,s=l(e,r),f=l(e,o);if(s>0&&e[s]>r&&s--,f<e.length-1&&e[f]<o&&f++,f-s<i)return{x:e.slice(s,f+1),y:t.slice(s,f+1)};let h=[e[s]],a=[t[s]],u=Number.MAX_VALUE,c=Number.MIN_VALUE;i=i%2==0?i/2+1:(i-1)/2+1;let g=(e[f]-e[s])/(i-1),d=e[s]+g,x=!0;for(let n=s+1;n<=f;n++)x?(u=t[n],c=t[n],x=!1):(t[n]<u&&(u=t[n]),t[n]>c&&(c=t[n])),(e[n]>=d||n===f)&&(h.push(d-g/2),a.push(u),h.push(d),a.push(c),d+=g,x=!0);return{x:h,y:a}},sortX:function(e){const{x:t,y:n}=e;if(t.length!==n.length)throw TypeError("sortX: length of x and y must be identical");return t.length<2||t[0]<t[1]?e:{x:t.slice(0).reverse(),y:n.slice(0).reverse()}},minClosestYPoint:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(e);const{x:r,y:o}=e;let{target:i,targetIndex:s}=t;void 0===s&&(s=void 0!==i?l(r,i):0);let f=Number.MIN_SAFE_INTEGER,h=s,a=o[s];for(;h!==f;)f=h,h>0&&o[h-1]<a?h--:h<r.length-1&&o[h+1]<a&&h++,a=o[h];return{x:r[h],y:o[h],index:h}},maxClosestYPoint:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(e);const{x:r,y:o}=e;let{target:i,targetIndex:s}=t;void 0===s&&(s=void 0!==i?l(r,i):0);let f=Number.MIN_SAFE_INTEGER,h=s,a=o[s];for(;h!==f;)f=h,h>0&&o[h-1]>a?h--:h<r.length-1&&o[h+1]>a&&h++,a=o[h];return{x:r[h],y:o[h],index:h}},realMaxYPoint:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(e);const{x:r,y:l}=e,o=i(r,t);if(l[o-1]>0&&l[o+1]>0&&l[o]>=l[o-1]&&l[o]>=l[o+1]){let e=20*Math.log10(l[o-1]),t=20*Math.log10(l[o]),n=20*Math.log10(l[o+1]),i=.5*(e-n)/(e-2*t+n);return{x:r[o]+(r[o]-r[o-1])*i,y:l[o]-.25*(l[o-1]-l[o+1])*i,index:o}}return{x:r[o],y:l[o],index:o}},realMinYPoint:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(e);const{x:r,y:l}=e,o=i(r,t);if(l[o-1]<0&&l[o+1]<0&&l[o]<=l[o-1]&&l[o]<=l[o+1]){let e=20*Math.log10(-l[o-1]),t=20*Math.log10(-l[o]),n=20*Math.log10(-l[o+1]),i=.5*(e-n)/(e-2*t+n);return{x:r[o]+(r[o]-r[o-1])*i,y:l[o]-.25*(l[o-1]-l[o+1])*i,index:o}}return{x:r[o],y:l[o],index:o}},peakInfo:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(e);const{x:r,y:o}=e;if(r.length<3)return;let{targetIndex:i,target:s}=t;if(void 0===i&&void 0!==s&&(i=l(r,s)),void 0===i)throw new Error("peakInfo: need to specify target or targetIndex");let f=i,h=o[f]-o[f+1],a=h<0?-1:1;for(h*=a;f<r.length-1;){let e=(o[++f]-o[f+1])*a;if(e<h)break;h=e}let u={x:r[f],y:o[f]};for(h=(o[f=i]-o[f-1])*a;f>1;){let e=(o[--f]-o[f-1])*a;if(e<h)break;h=e}let c={x:r[f],y:o[f]};return{inflectionBefore:c,inflectionAfter:u,extrema:{x:r[i],y:o[i]},inflectionMiddle:{x:(c.x+u.x)/2,y:(c.y+u.y)/2},width:Math.abs(c.x-u.x)}}};const f={zeroFilling:function(e,t){let n=e.x.length;if(0===t||n===t)return e;if(n>t)return{x:e.x.slice(0,t),re:e.re.slice(0,t),im:e.im.slice(0,t)};const r=e.x,l=e.re,o=e.im,i=new Float64Array(t),s=new Float64Array(t),f=new Float64Array(t);for(let e=0;e<n;e++)i[e]=r[e],s[e]=l[e],f[e]=o[e];const h=(r[r.length-1]-r[0])/(n-1);for(let e=n;e<t;e++)i[e]=i[e-1]+h;return{x:i,re:s,im:f}},sortX:function(e){const{x:t,re:n,im:r}=e;if(t.length!==n.length||t.length!==r.length)throw TypeError("sortX: length of x, re and im must be identical");return t.length<2||t[0]<t[1]?e:{x:t.slice(0).reverse(),re:n.slice(0).reverse(),im:r.slice(0).reverse()}}};const h={absolute:function(e){const t=e.re.length,n=e.re,r=e.im,l=new Float64Array(t);for(let e=0;e<t;e++)l[e]=Math.sqrt(n[e]**2+r[e]**2);return l},phaseCorrection:function(e,t,n){t=Number.isFinite(t)?t:0,n=Number.isFinite(n)?n:0;const r=e.re.slice(0),l=e.im.slice(0),o=e.re.length,i=n/o,s=2*Math.pow(Math.sin(i/2),2),f=Math.sin(i);let h=Math.cos(t),a=Math.sin(t);const u=new Float64Array(o),c=new Float64Array(o);for(let e=0;e<o;e++)u[e]=r[e]*h-l[e]*a,c[e]=r[e]*a+l[e]*h,a-=s*a-f*(h-=s*h+f*a);return{re:u,im:c}}};const a={add:function(e,t){let n,r=!1;if(Array.isArray(t)){if(e.length!==t.length)throw new Error("sub: size of array1 and array2 must be identical")}else r=!0,n=Number(t);let l=new Array(e.length);if(r)for(let t=0;t<e.length;t++)l[t]=e[t]+n;else for(let n=0;n<e.length;n++)l[n]=e[n]+t[n];return l},boxPlot:function(e){if((e=e.slice(0).sort((e,t)=>e-t)).length<5)throw Error("boxPlot: can not calculate info if array contains less than 3 elements");let t,n,r={Q1:0,Q2:0,Q3:0,min:e[0],max:e[e.length-1]};if(e.length%2==1){let l=(e.length-1)/2;r.Q2=e[l],t=l-1,n=l+1}else t=(n=e.length/2)-1,r.Q2=(e[t]+e[n])/2;if(t%2==0)r.Q1=e[t/2],r.Q3=e[(e.length+n-1)/2];else{r.Q1=(e[(t+1)/2]+e[(t-1)/2])/2;let l=(e.length+n)/2;r.Q3=(e[l]+e[l-1])/2}return r},divide:function(e,t){let n,r=!1;if(Array.isArray(t)){if(e.length!==t.length)throw new Error("sub: size of array1 and array2 must be identical")}else r=!0,n=Number(t);let l=new Array(e.length);if(r)for(let t=0;t<e.length;t++)l[t]=e[t]/n;else for(let n=0;n<e.length;n++)l[n]=e[n]/t[n];return l},findClosestIndex:l,getTargetIndex:i,multiply:function(e,t){let n,r=!1;if(Array.isArray(t)){if(e.length!==t.length)throw new Error("sub: size of array1 and array2 must be identical")}else r=!0,n=Number(t);let l=new Array(e.length);if(r)for(let t=0;t<e.length;t++)l[t]=e[t]*n;else for(let n=0;n<e.length;n++)l[n]=e[n]*t[n];return l},rotate:function(e,t){return(t%=e.length)<0&&(t+=e.length),e.slice(e.length-t).concat(e.slice(0,e.length-t))},subtract:function(e,t){let n,r=!1;if(Array.isArray(t)){if(e.length!==t.length)throw new Error("sub: size of array1 and array2 must be identical")}else r=!0,n=Number(t);let l=new Array(e.length);if(r)for(let t=0;t<e.length;t++)l[t]=e[t]-n;else for(let n=0;n<e.length;n++)l[n]=e[n]-t[n];return l},correlation:function(e,t){let n=e.length,r=0,l=0,o=0,i=0,s=0;for(let f=0;f<n;f++){let n=e[f],h=t[f];r+=n,l+=n**2,o+=h,i+=h**2,s+=n*h}return(n*s-r*o)/(Math.sqrt(n*l-r**2)*Math.sqrt(n*i-o**2))}};t.ReIm=h,t.X=a,t.XReIm=f,t.XY=s})),o=(n=l)&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n,i=l.ReIm,s=l.X,f=l.XReIm,h=l.XY;e.ReIm=i,e.X=s,e.XReIm=f,e.XY=h,e.default=o,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=ml-spectra-processing.min.js.map
