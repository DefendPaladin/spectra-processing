!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e=e||self).SpectraProcessing={})}(this,(function(e){"use strict";const t=Object.prototype.toString;var n,r=function(e){return t.call(e).endsWith("Array]")},o=function(e,t){return e(t={exports:{}},t.exports),t.exports}((function(e,t){function n(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!r(e.x)||!r(e.y))throw new Error("Points must be an object of x and y arrays");if(e.x.length!==e.y.length)throw new Error("The x and y arrays mush have the same length")}function o(e,t){let n=0,r=e.length-1,o=0;for(;r-n>1;)if(o=n+(r-n>>1),e[o]<t)n=o;else{if(!(e[o]>t))return o;r=o}return n<e.length-1?Math.abs(t-e[n])<Math.abs(e[n+1]-t)?n:n+1:n}function l(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{fromIndex:n,toIndex:r,from:l,to:i}=t;return void 0===n&&(n=void 0!==l?o(e,l):0),void 0===r&&(r=void 0!==i?o(e,i):e.length-1),n>r&&([n,r]=[r,n]),{fromIndex:n,toIndex:r}}function i(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},{target:n,targetIndex:r}=t;return void 0===r?void 0!==n?o(e,n):0:r}Object.defineProperty(t,"__esModule",{value:!0});const s={check:n,integral:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{reverse:r=!1}=t;n(e);const{x:o,y:i}=e;if(o.length<2)return 0;const{fromIndex:s,toIndex:f}=l(o,t);let h,u=0;if(r){h={x:[o[f]],y:[0]};for(let e=f;e>s;e--)u+=(o[e]-o[e-1])*(i[e-1]+i[e])/2,h.x.push(o[e-1]),h.y.push(u);h.x.reverse(),h.y.reverse()}else{h={x:[o[s]],y:[0]};for(let e=s;e<f;e++)u+=(o[e+1]-o[e])*(i[e+1]+i[e])/2,h.x.push(o[e+1]),h.y.push(u)}return h},integration:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(e);const{x:r,y:o}=e;if(r.length<2)return 0;const{fromIndex:i,toIndex:s}=l(r,t);let f=0;for(let e=i;e<s;e++)f+=(r[e+1]-r[e])*(o[e+1]+o[e])/2;return f},maxY:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(e);const{x:r,y:o}=e;if(r.length<2)return 0;const{fromIndex:i,toIndex:s}=l(r,t);let f=o[i];for(let e=i;e<=s;e++)o[e]>f&&(f=o[e]);return f},maximaY:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};n(e);const{x:t,y:r}=e;if(t.length<3)return[];let o=[],l=-1;for(let e=1;e<t.length-1;e++)if(r[e-1]<r[e]&&r[e+1]<r[e])o.push({x:t[e],y:r[e],index:e});else if(r[e-1]<r[e]&&r[e+1]===r[e])l=e;else if(r[e-1]===r[e]&&r[e+1]<r[e]){let n=(e+l)/2>>0;o.push({x:t[n],y:r[n],index:n})}return o},maxYPoint:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(e);const{x:r,y:o}=e;if(r.length<2)return 0;const{fromIndex:i,toIndex:s}=l(r,t);let f={x:r[i],y:o[i],index:i};for(let e=i;e<=s;e++)o[e]>f.y&&(f={x:r[e],y:o[e],index:e});return f},minimaY:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};n(e);const{x:t,y:r}=e;if(t.length<3)return[];let o=[],l=-1;for(let e=1;e<t.length-1;e++)if(r[e-1]>r[e]&&r[e+1]>r[e])o.push({x:t[e],y:r[e],index:e});else if(r[e-1]>r[e]&&r[e+1]===r[e])l=e;else if(r[e-1]===r[e]&&r[e+1]>r[e]){let n=(e+l)/2>>0;o.push({x:t[n],y:r[n],index:n})}return o},minYPoint:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(e);const{x:r,y:o}=e;if(r.length<2)return 0;const{fromIndex:i,toIndex:s}=l(r,t);let f={x:r[i],y:o[i],index:i};for(let e=i;e<=s;e++)o[e]<f.y&&(f={x:r[e],y:o[e],index:e});return f},reduce:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{from:r=e[0],to:l=e[e.length-1],nbPoints:i=4001,optimize:s=!1}=n,f=o(e,r),h=o(e,l);if(f>0&&e[f]>r&&f--,h<e.length-1&&e[h]<l&&h++,h-f<i)return{x:e.slice(f,h+1),y:t.slice(f,h+1)};let u=[e[f]],a=[t[f]],c=Number.MAX_VALUE,g=Number.MIN_VALUE;i=i%2==0?i/2+1:(i-1)/2+1;let x=(e[h]-e[f])/(i-1),d=e[f]+x,y=!0;for(let n=f+1;n<=h;n++)y?(c=t[n],g=t[n],y=!1):(t[n]<c&&(c=t[n]),t[n]>g&&(g=t[n])),(e[n]>=d||n===h)&&(s?c>a[u.length-1]||(g<a[u.length-1]?g=c:(u.push(d-x/2),a.push(c))):(u.push(d-x/2),a.push(c)),u.push(d),a.push(g),d+=x,y=!0);return{x:u,y:a}},growingX:function(e){const{x:t,y:n}=e;if(t.length!==n.length)throw TypeError("sortX: length of x and y must be identical");return t.length<2||t[0]<t[1]?e:{x:t.slice(0).reverse(),y:n.slice(0).reverse()}},minClosestYPoint:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(e);const{x:r,y:l}=e;let{target:i,targetIndex:s}=t;void 0===s&&(s=void 0!==i?o(r,i):0);let f=Number.MIN_SAFE_INTEGER,h=s,u=l[s];for(;h!==f;)f=h,h>0&&l[h-1]<u?h--:h<r.length-1&&l[h+1]<u&&h++,u=l[h];return{x:r[h],y:l[h],index:h}},maxClosestYPoint:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(e);const{x:r,y:l}=e;let{target:i,targetIndex:s}=t;void 0===s&&(s=void 0!==i?o(r,i):0);let f=Number.MIN_SAFE_INTEGER,h=s,u=l[s];for(;h!==f;)f=h,h>0&&l[h-1]>u?h--:h<r.length-1&&l[h+1]>u&&h++,u=l[h];return{x:r[h],y:l[h],index:h}},realMaxYPoint:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(e);const{x:r,y:o}=e,l=i(r,t);if(o[l-1]>0&&o[l+1]>0&&o[l]>=o[l-1]&&o[l]>=o[l+1]){let e=20*Math.log10(o[l-1]),t=20*Math.log10(o[l]),n=20*Math.log10(o[l+1]),i=.5*(e-n)/(e-2*t+n);return{x:r[l]+(r[l]-r[l-1])*i,y:o[l]-.25*(o[l-1]-o[l+1])*i,index:l}}return{x:r[l],y:o[l],index:l}},realMinYPoint:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(e);const{x:r,y:o}=e,l=i(r,t);if(o[l-1]<0&&o[l+1]<0&&o[l]<=o[l-1]&&o[l]<=o[l+1]){let e=20*Math.log10(-o[l-1]),t=20*Math.log10(-o[l]),n=20*Math.log10(-o[l+1]),i=.5*(e-n)/(e-2*t+n);return{x:r[l]+(r[l]-r[l-1])*i,y:o[l]-.25*(o[l-1]-o[l+1])*i,index:l}}return{x:r[l],y:o[l],index:l}},peakInfo:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};n(e);const{x:r,y:l}=e;if(r.length<3)return;let{targetIndex:i,target:s}=t;if(void 0===i&&void 0!==s&&(i=o(r,s)),void 0===i)throw new Error("peakInfo: need to specify target or targetIndex");let f=i,h=l[f]-l[f+1],u=h<0?-1:1;for(h*=u;f<r.length-1;){f++;let e=(l[f]-l[f+1])*u;if(e<h)break;h=e}let a={x:r[f],y:l[f]};for(f=i,h=(l[f]-l[f-1])*u;f>1;){f--;let e=(l[f]-l[f-1])*u;if(e<h)break;h=e}let c={x:r[f],y:l[f]};return{inflectionBefore:c,inflectionAfter:a,extrema:{x:r[i],y:l[i]},inflectionMiddle:{x:(c.x+a.x)/2,y:(c.y+a.y)/2},width:Math.abs(c.x-a.x)}},toXYObject:function(e){n(e);const{x:t,y:r}=e;let o=[];for(let e=0;e<t.length;e++)o.push({x:t[e],y:r[e]});return o}};const f={zeroFilling:function(e,t){let n=e.x.length;if(0===t||n===t)return e;if(n>t)return{x:e.x.slice(0,t),re:e.re.slice(0,t),im:e.im.slice(0,t)};const r=e.x,o=e.re,l=e.im,i=new Float64Array(t),s=new Float64Array(t),f=new Float64Array(t);for(let e=0;e<n;e++)i[e]=r[e],s[e]=o[e],f[e]=l[e];const h=(r[r.length-1]-r[0])/(n-1);for(let e=n;e<t;e++)i[e]=i[e-1]+h;return{x:i,re:s,im:f}},sortX:function(e){const{x:t,re:n,im:r}=e;if(t.length!==n.length||t.length!==r.length)throw TypeError("sortX: length of x, re and im must be identical");return t.length<2||t[0]<t[1]?e:{x:t.slice(0).reverse(),re:n.slice(0).reverse(),im:r.slice(0).reverse()}}};const h={absolute:function(e){const t=e.re.length,n=e.re,r=e.im,o=new Float64Array(t);for(let e=0;e<t;e++)o[e]=Math.sqrt(n[e]**2+r[e]**2);return o},phaseCorrection:function(e,t,n){t=Number.isFinite(t)?t:0,n=Number.isFinite(n)?n:0;const r=e.re,o=e.im,l=e.re.length,i=n/l,s=2*Math.pow(Math.sin(i/2),2),f=Math.sin(i);let h=Math.cos(t),u=Math.sin(t);const a=new Float64Array(l),c=new Float64Array(l);for(let e=0;e<l;e++)a[e]=r[e]*h-o[e]*u,c[e]=r[e]*u+o[e]*h,h-=s*h+f*u,u-=s*u-f*h;return{re:a,im:c}}};function u(e,t){let n,r=!1;if(Array.isArray(t)){if(e.length!==t.length)throw new Error("sub: size of array1 and array2 must be identical")}else r=!0,n=Number(t);let o=new Float64Array(e.length);if(r)for(let t=0;t<e.length;t++)o[t]=e[t]*n;else for(let n=0;n<e.length;n++)o[n]=e[n]*t[n];return o}function a(e,t){let n=u(e,t),r=0;for(let t=0;t<e.length;t++)r+=n[t];return r}function c(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},{tau:r=1,lag:o=e.length-1}=n,l=new Float64Array(1+2*o/r);if(e.length===t.length){let n=t.length,i=new Float64Array(2*n),s=new Float64Array(2*n);for(let e=0;e<n;e++)s[n+e]=t[e];for(let t=2*n-(r-1);t>0;t-=r){let f=0;for(let e=t;e<2*n;e++)i[f]=s[e],f++;let h=[];for(let e=0;e<n;e++)h[e]=i[e];l[(f-(n-o))/r]=a(e,h)}}return l}const g={add:function(e,t){let n,r=!1;if(Array.isArray(t)){if(e.length!==t.length)throw new Error("sub: size of array1 and array2 must be identical")}else r=!0,n=Number(t);let o=new Array(e.length);if(r)for(let t=0;t<e.length;t++)o[t]=e[t]+n;else for(let n=0;n<e.length;n++)o[n]=e[n]+t[n];return o},autoCorrelation:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return c(e,e,t)},boxPlot:function(e){if((e=e.slice(0).sort((e,t)=>e-t)).length<5)throw Error("boxPlot: can not calculate info if array contains less than 3 elements");let t,n,r={Q1:0,Q2:0,Q3:0,min:e[0],max:e[e.length-1]};if(e.length%2==1){let o=(e.length-1)/2;r.Q2=e[o],t=o-1,n=o+1}else n=e.length/2,t=n-1,r.Q2=(e[t]+e[n])/2;if(t%2==0)r.Q1=e[t/2],r.Q3=e[(e.length+n-1)/2];else{r.Q1=(e[(t+1)/2]+e[(t-1)/2])/2;let o=(e.length+n)/2;r.Q3=(e[o]+e[o-1])/2}return r},correlation:function(e,t){let n=e.length,r=0,o=0,l=0,i=0,s=0;for(let f=0;f<n;f++){let n=e[f],h=t[f];r+=n,o+=n**2,l+=h,i+=h**2,s+=n*h}return(n*s-r*l)/(Math.sqrt(n*o-r**2)*Math.sqrt(n*i-l**2))},crossCorrelation:c,divide:function(e,t){let n,r=!1;if(Array.isArray(t)){if(e.length!==t.length)throw new Error("sub: size of array1 and array2 must be identical")}else r=!0,n=Number(t);let o=new Array(e.length);if(r)for(let t=0;t<e.length;t++)o[t]=e[t]/n;else for(let n=0;n<e.length;n++)o[n]=e[n]/t[n];return o},findClosestIndex:o,getFromToIndex:l,getTargetIndex:i,multiply:u,rotate:function(e,t){return(t%=e.length)<0&&(t+=e.length),e.slice(e.length-t).concat(e.slice(0,e.length-t))},subtract:function(e,t){let n,r=!1;if(Array.isArray(t)){if(e.length!==t.length)throw new Error("sub: size of array1 and array2 must be identical")}else r=!0,n=Number(t);let o=new Array(e.length);if(r)for(let t=0;t<e.length;t++)o[t]=e[t]-n;else for(let n=0;n<e.length;n++)o[n]=e[n]-t[n];return o}};const x={joinX:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{xError:n=Number.EPSILON}=t;let r=[],o={x:Number.MIN_SAFE_INTEGER,y:0};for(let t of e)t.x-o.x<=n?(o.x=t.y/(o.y+t.y)*(t.x-o.x)+o.x,o.y+=t.y):(o={x:t.x,y:t.y},r.push(o));return r},slotX:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{slotWidth:n=1}=t,r=n/2;let o=[],l={x:Number.MIN_VALUE,y:0};for(let t of e){let e=t.x-(t.x+r)%n+r;Math.abs(l.x-e)>Number.EPSILON&&(l={x:e,y:0},o.push(l)),l.y+=t.y}return o},sortX:function(e){return e.sort((e,t)=>e.x-t.x)},toXY:function(e){return{x:e.map(e=>e.x),y:e.map(e=>e.y)}}};t.ReIm=h,t.X=g,t.XReIm=f,t.XY=s,t.XYObject=x})),l=(n=o)&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n,i=o.ReIm,s=o.X,f=o.XReIm,h=o.XY,u=o.XYObject;e.ReIm=i,e.X=s,e.XReIm=f,e.XY=h,e.XYObject=u,e.default=l,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=ml-spectra-processing.min.js.map
