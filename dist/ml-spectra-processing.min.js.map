{"version":3,"file":"ml-spectra-processing.min.js","sources":["../node_modules/is-any-array/src/index.js","../lib/index.js"],"sourcesContent":["'use strict';\n\nconst toString = Object.prototype.toString;\n\nfunction isAnyArray(object) {\n  return toString.call(object).endsWith('Array]');\n}\n\nmodule.exports = isAnyArray;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst isAnyArray = require('is-any-array');\n\n/**\n * Throw an error in no an object of x,y arrays\n * @param {object} [points={}]\n */\nfunction check(points = {}) {\n  if (!isAnyArray(points.x) || !isAnyArray(points.y)) {\n    throw new Error('Points must be an object of x and y arrays');\n  }\n  if (points.x.length !== points.y.length) {\n    throw new Error('The x and y arrays mush have the same length');\n  }\n}\n\n/**\n * Returns the closest index of a `target` in an ordered array\n * @param {array} array\n * @param {number} target\n */\n\nfunction findClosestIndex(array, target) {\n  let low = 0;\n  let high = array.length - 1;\n  let middle = 0;\n  while (high - low > 1) {\n    middle = low + ((high - low) >> 1);\n    if (array[middle] < target) {\n      low = middle;\n    } else if (array[middle] > target) {\n      high = middle;\n    } else {\n      return middle;\n    }\n  }\n\n  if (low < array.length - 1) {\n    if (Math.abs(target - array[low]) < Math.abs(array[low + 1] - target)) {\n      return low;\n    } else {\n      return low + 1;\n    }\n  } else {\n    return low;\n  }\n}\n\n/**\n * Returns an object with {fromIndex, toIndex} for a specific from / to\n * @param {array} x\n * @param {object} [options={}]\n * @param {number} [options.from] - First value for integration in the X scale\n * @param {number} [options.fromIndex=0] - First point for integration\n * @param {number} [options.to] - Last value for integration in the X scale\n * @param {number} [options.toIndex=x.length-1] - Last point for integration\n */\n\nfunction getFromToIndex(x, options = {}) {\n  let { fromIndex, toIndex, from, to } = options;\n\n  if (fromIndex === undefined) {\n    if (from !== undefined) {\n      fromIndex = findClosestIndex(x, from);\n    } else {\n      fromIndex = 0;\n    }\n  }\n  if (toIndex === undefined) {\n    if (to !== undefined) {\n      toIndex = findClosestIndex(x, to);\n    } else {\n      toIndex = x.length - 1;\n    }\n  }\n  if (fromIndex > toIndex) [fromIndex, toIndex] = [toIndex, fromIndex];\n  return { fromIndex, toIndex };\n}\n\n/**\n * In place modification of the 2 arrays to make X unique and sum the Y if X has the same value\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.from] - First value for integration in the X scale\n * @param {number} [options.fromIndex=0] - First point for integration\n * @param {number} [options.to] - Last value for integration in the X scale\n * @param {number} [options.toIndex=x.length-1] - Last point for integration\n * @return {number} Integration value on the specified range\n */\n\nfunction integration(points = {}, options = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 2) return 0;\n  const { fromIndex, toIndex } = getFromToIndex(x, options);\n  let integration = 0;\n  for (let i = fromIndex; i < toIndex; i++) {\n    integration += ((x[i + 1] - x[i]) * (y[i + 1] + y[i])) / 2;\n  }\n\n  return integration;\n}\n\n/**\n * Generate a X / Y of the integral\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.from] - First value for integration in the X scale\n * @param {number} [options.fromIndex=0] - First point for integration\n * @param {number} [options.to] - Last value for integration in the X scale\n * @param {number} [options.toIndex=x.length-1] - Last point for integration\n * @param {boolean} [options.reverse=false] - Integrate from the larger value to the smallest value\n * @return {{x:[],y:[]}} An object with the integration function\n */\n\nfunction integral(points = {}, options = {}) {\n  const { reverse = false } = options;\n  check(points);\n  const { x, y } = points;\n  if (x.length < 2) return 0;\n\n  const { fromIndex, toIndex } = getFromToIndex(x, options);\n\n  let integration = 0;\n  let integral;\n  if (reverse) {\n    integral = { x: [x[toIndex]], y: [0] };\n    for (let i = toIndex; i > fromIndex; i--) {\n      integration += ((x[i] - x[i - 1]) * (y[i - 1] + y[i])) / 2;\n      integral.x.push(x[i - 1]);\n      integral.y.push(integration);\n    }\n    integral.x.reverse();\n    integral.y.reverse();\n  } else {\n    integral = { x: [x[fromIndex]], y: [0] };\n    for (let i = fromIndex; i < toIndex; i++) {\n      integration += ((x[i + 1] - x[i]) * (y[i + 1] + y[i])) / 2;\n      integral.x.push(x[i + 1]);\n      integral.y.push(integration);\n    }\n  }\n\n  return integral;\n}\n\n/**\n * Finds the max value in a zone\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.from] - First value for integration in the X scale\n * @param {number} [options.fromIndex=0] - First point for integration\n * @param {number} [options.to] - Last value for integration in the X scale\n * @param {number} [options.toIndex=x.length-1] - Last point for integration\n * @return {number} Max y on the specified range\n */\n\nfunction maxY(points = {}, options = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 2) return 0;\n\n  const { fromIndex, toIndex } = getFromToIndex(x, options);\n\n  let maxY = y[fromIndex];\n  for (let i = fromIndex; i <= toIndex; i++) {\n    if (y[i] > maxY) maxY = y[i];\n  }\n\n  return maxY;\n}\n\n/**\n * Finds the max y value in a range and return a {x,y} point\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.from] - First value for integration in the X scale\n * @param {number} [options.fromIndex=0] - First point for integration\n * @param {number} [options.to] - Last value for integration in the X scale\n * @param {number} [options.toIndex=x.length-1] - Last point for integration\n * @return {object}\n */\n\nfunction maxYPoint(points = {}, options = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 2) return 0;\n\n  const { fromIndex, toIndex } = getFromToIndex(x, options);\n\n  let current = { x: x[fromIndex], y: y[fromIndex], index: fromIndex };\n  for (let i = fromIndex; i <= toIndex; i++) {\n    if (y[i] > current.y) current = { x: x[i], y: y[i], index: i };\n  }\n\n  return current;\n}\n\n/**\n * Finds the max y value in a range and return a {x,y} point\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.from] - First value for integration in the X scale\n * @param {number} [options.fromIndex=0] - First point for integration\n * @param {number} [options.to] - Last value for integration in the X scale\n * @param {number} [options.toIndex=x.length-1] - Last point for integration\n * @return {object}\n */\n\nfunction minYPoint(points = {}, options = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 2) return 0;\n\n  const { fromIndex, toIndex } = getFromToIndex(x, options);\n\n  let current = { x: x[fromIndex], y: y[fromIndex], index: fromIndex };\n  for (let i = fromIndex; i <= toIndex; i++) {\n    if (y[i] < current.y) current = { x: x[i], y: y[i], index: i };\n  }\n\n  return current;\n}\n\n/**\n * Reduce the number of points while keeping visually the same noise. Practical to\n * display many spectra as SVG\n * @param {array} x\n * @param {array} y\n * @param {object} [options={}]\n * @param {number} [options.from=x[0]]\n * @param {number} [options.to=x[x.length-1]]\n * @param {number} [options.nbPoints=4001] Number of points\n * @param {number} [options.optimize=false] If optimize we may have less than nbPoints at the end\n */\n\nfunction reduce(x, y, options = {}) {\n  let {\n    from = x[0],\n    to = x[x.length - 1],\n    nbPoints = 4001,\n    optimize = false,\n  } = options;\n\n  let fromIndex = findClosestIndex(x, from);\n  let toIndex = findClosestIndex(x, to);\n\n  if (fromIndex > 0 && x[fromIndex] > from) fromIndex--;\n  if (toIndex < x.length - 1 && x[toIndex] < to) toIndex++;\n\n  if (toIndex - fromIndex < nbPoints) {\n    return {\n      x: x.slice(fromIndex, toIndex + 1),\n      y: y.slice(fromIndex, toIndex + 1),\n    };\n  }\n\n  let newX = [x[fromIndex]];\n  let newY = [y[fromIndex]];\n  let minY = Number.MAX_VALUE;\n  let maxY = Number.MIN_VALUE;\n  if (nbPoints % 2 === 0) {\n    nbPoints = nbPoints / 2 + 1;\n  } else {\n    nbPoints = (nbPoints - 1) / 2 + 1;\n  }\n\n  let slot = (x[toIndex] - x[fromIndex]) / (nbPoints - 1);\n  let currentX = x[fromIndex] + slot;\n  let first = true;\n  for (let i = fromIndex + 1; i <= toIndex; i++) {\n    if (first) {\n      minY = y[i];\n      maxY = y[i];\n      first = false;\n    } else {\n      if (y[i] < minY) minY = y[i];\n      if (y[i] > maxY) maxY = y[i];\n    }\n    if (x[i] >= currentX || i === toIndex) {\n      if (optimize) {\n        if (minY > newY[newX.length - 1]) ; else if (maxY < newY[newX.length - 1]) {\n          // we can skip the intermediate value\n          maxY = minY;\n        } else {\n          newX.push(currentX - slot / 2);\n          newY.push(minY);\n        }\n      } else {\n        newX.push(currentX - slot / 2);\n        newY.push(minY);\n      }\n\n      newX.push(currentX);\n      newY.push(maxY);\n\n      currentX += slot;\n      first = true;\n    }\n  }\n\n  // we will need to make some kind of min / max because there are too many points\n  // we will always keep the first point and the last point\n\n  return { x: newX, y: newY };\n}\n\n/**\n * Order object of array, x has to be monotone.\n * Ensure x is growing\n * @param {object} data Object of kind {x:[], y:[]}.\n * @return {SD}\n */\n\nfunction growingX(data) {\n  const { x, y } = data;\n\n  if (x.length !== y.length) {\n    throw TypeError('sortX: length of x and y must be identical');\n  }\n\n  if (x.length < 2 || x[0] < x[1]) return data;\n\n  return {\n    x: x.slice(0).reverse(),\n    y: y.slice(0).reverse(),\n  };\n}\n\n/**\n * Find the closest minimum going down hill\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.target]\n * @param {number} [options.targetIndex=0]\n * @return {{x,y,xIndex}} An object with the x/y value\n */\n\nfunction minClosestYPoint(points, options = {}) {\n  check(points);\n  const { x, y } = points;\n\n  let { target, targetIndex } = options;\n\n  if (targetIndex === undefined) {\n    if (target !== undefined) {\n      targetIndex = findClosestIndex(x, target);\n    } else {\n      targetIndex = 0;\n    }\n  }\n\n  let previousIndex = Number.MIN_SAFE_INTEGER;\n  let currentIndex = targetIndex;\n\n  let minY = y[targetIndex];\n\n  while (currentIndex !== previousIndex) {\n    previousIndex = currentIndex;\n    if (currentIndex > 0 && y[currentIndex - 1] < minY) {\n      currentIndex--;\n    } else if (currentIndex < x.length - 1 && y[currentIndex + 1] < minY) {\n      currentIndex++;\n    }\n    minY = y[currentIndex];\n  }\n  return {\n    x: x[currentIndex],\n    y: y[currentIndex],\n    index: currentIndex,\n  };\n}\n\n/**\n * Find the closest maximum going up hill\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.target]\n * @param {number} [options.targetIndex=0]\n * @return {{x,y,xIndex}} An object with the x/y value\n */\n\nfunction maxClosestYPoint(points, options = {}) {\n  check(points);\n  const { x, y } = points;\n\n  let { target, targetIndex } = options;\n\n  if (targetIndex === undefined) {\n    if (target !== undefined) {\n      targetIndex = findClosestIndex(x, target);\n    } else {\n      targetIndex = 0;\n    }\n  }\n\n  let previousIndex = Number.MIN_SAFE_INTEGER;\n  let currentIndex = targetIndex;\n\n  let maxY = y[targetIndex];\n\n  while (currentIndex !== previousIndex) {\n    previousIndex = currentIndex;\n    if (currentIndex > 0 && y[currentIndex - 1] > maxY) {\n      currentIndex--;\n    } else if (currentIndex < x.length - 1 && y[currentIndex + 1] > maxY) {\n      currentIndex++;\n    }\n    maxY = y[currentIndex];\n  }\n  return {\n    x: x[currentIndex],\n    y: y[currentIndex],\n    index: currentIndex,\n  };\n}\n\n/**\n *  Returns the targetIndex\n * @param {array} [x]\n * @param {object} [options={}]\n * @param {number} [options.target]\n * @param {number} [options.targetIndex=0]\n * @param {number}\n */\n\nfunction getTargetIndex(x, options = {}) {\n  let { target, targetIndex } = options;\n  if (targetIndex === undefined) {\n    if (target !== undefined) {\n      return findClosestIndex(x, target);\n    } else {\n      return 0;\n    }\n  }\n  return targetIndex;\n}\n\nfunction realMinYPoint(points, options = {}) {\n  check(points);\n  const { x, y } = points;\n\n  const targetIndex = getTargetIndex(x, options);\n  // interpolation to a sin() function\n  if (\n    y[targetIndex - 1] < 0 &&\n    y[targetIndex + 1] < 0 &&\n    y[targetIndex] <= y[targetIndex - 1] &&\n    y[targetIndex] <= y[targetIndex + 1]\n  ) {\n    let alpha = 20 * Math.log10(-y[targetIndex - 1]);\n    let beta = 20 * Math.log10(-y[targetIndex]);\n    let gamma = 20 * Math.log10(-y[targetIndex + 1]);\n    let p = (0.5 * (alpha - gamma)) / (alpha - 2 * beta + gamma);\n    return {\n      x: x[targetIndex] + (x[targetIndex] - x[targetIndex - 1]) * p,\n      y: y[targetIndex] - 0.25 * (y[targetIndex - 1] - y[targetIndex + 1]) * p,\n      index: targetIndex,\n    };\n  } else {\n    return {\n      x: x[targetIndex],\n      y: y[targetIndex],\n      index: targetIndex,\n    };\n  }\n}\n\n/**\n * Find the closest minimum going down hill\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.target]\n * @param {number} [options.targetIndex=0]\n * @return {{x,y,xIndex}} An object with the x/y value\n */\n\nfunction realMaxYPoint(points, options = {}) {\n  check(points);\n  const { x, y } = points;\n  const targetIndex = getTargetIndex(x, options);\n  // interpolation to a sin() function\n  if (\n    y[targetIndex - 1] > 0 &&\n    y[targetIndex + 1] > 0 &&\n    y[targetIndex] >= y[targetIndex - 1] &&\n    y[targetIndex] >= y[targetIndex + 1]\n  ) {\n    let alpha = 20 * Math.log10(y[targetIndex - 1]);\n    let beta = 20 * Math.log10(y[targetIndex]);\n    let gamma = 20 * Math.log10(y[targetIndex + 1]);\n    let p = (0.5 * (alpha - gamma)) / (alpha - 2 * beta + gamma);\n    return {\n      x: x[targetIndex] + (x[targetIndex] - x[targetIndex - 1]) * p,\n      y: y[targetIndex] - 0.25 * (y[targetIndex - 1] - y[targetIndex + 1]) * p,\n      index: targetIndex,\n    };\n  } else {\n    return {\n      x: x[targetIndex],\n      y: y[targetIndex],\n      index: targetIndex,\n    };\n  }\n}\n\n/**\n * Finds all the max values\n * If the values are equal the middle\n * of the equal part will be the position of the signal!\n *\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @return {Array} Array of points\n */\n\nfunction maximaY(points = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 3) return [];\n  let maxima = [];\n  let startEqualIndex = -1;\n  for (let i = 1; i < x.length - 1; i++) {\n    if (y[i - 1] < y[i] && y[i + 1] < y[i]) {\n      maxima.push({ x: x[i], y: y[i], index: i });\n    } else if (y[i - 1] < y[i] && y[i + 1] === y[i]) {\n      startEqualIndex = i;\n    } else if (y[i - 1] === y[i] && y[i + 1] < y[i]) {\n      let index = ((i + startEqualIndex) / 2) >> 0;\n      maxima.push({ x: x[index], y: y[index], index });\n    }\n  }\n  return maxima;\n}\n\n/**\n * Finds all the min values\n * If the values are equal the middle\n * of the equal part will be the position of the signal!\n *\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @return {Array} Array of points\n */\n\nfunction minimaY(points = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 3) return [];\n  let maxima = [];\n  let startEqualIndex = -1;\n  for (let i = 1; i < x.length - 1; i++) {\n    if (y[i - 1] > y[i] && y[i + 1] > y[i]) {\n      maxima.push({ x: x[i], y: y[i], index: i });\n    } else if (y[i - 1] > y[i] && y[i + 1] === y[i]) {\n      startEqualIndex = i;\n    } else if (y[i - 1] === y[i] && y[i + 1] > y[i]) {\n      let index = ((i + startEqualIndex) / 2) >> 0;\n      maxima.push({ x: x[index], y: y[index], index });\n    }\n  }\n  return maxima;\n}\n\n/**\n * Returns an information about a signal\n *\n * We expect ordered data and equidistant X axis\n * You can use the method helper if required:\n * ML.ArrayXY.uniqueX\n * ML.ArrayXY.sortX\n * ML.ArrayXY.equallySpaced\n *\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.target]\n * @param {number} [options.targetIndex]\n * @return {object} Information about signal\n */\n\nfunction peakInfo(points = {}, options = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 3) return undefined;\n  let { targetIndex, target } = options;\n  if (targetIndex === undefined) {\n    if (target !== undefined) {\n      targetIndex = findClosestIndex(x, target);\n    }\n  }\n\n  if (targetIndex === undefined) {\n    throw new Error('peakInfo: need to specify target or targetIndex');\n  }\n\n  let i = targetIndex;\n  let currentDiff = y[i] - y[i + 1];\n\n  let multiplier = currentDiff < 0 ? -1 : 1;\n  currentDiff *= multiplier;\n  while (i < x.length - 1) {\n    i++;\n    let newDiff = (y[i] - y[i + 1]) * multiplier;\n    if (newDiff < currentDiff) break;\n    currentDiff = newDiff;\n  }\n  let after = { x: x[i], y: y[i] };\n\n  i = targetIndex;\n  currentDiff = (y[i] - y[i - 1]) * multiplier;\n  while (i > 1) {\n    i--;\n    let newDiff = (y[i] - y[i - 1]) * multiplier;\n    if (newDiff < currentDiff) break;\n    currentDiff = newDiff;\n  }\n  let before = { x: x[i], y: y[i] };\n\n  return {\n    inflectionBefore: before,\n    inflectionAfter: after,\n    extrema: { x: x[targetIndex], y: y[targetIndex] },\n    inflectionMiddle: {\n      x: (before.x + after.x) / 2,\n      y: (before.y + after.y) / 2,\n    },\n    width: Math.abs(before.x - after.x),\n  };\n}\n\n/**\n *\n * @param {array} [data] array of points {x,y}\n */\nfunction toXYObject(points) {\n  check(points);\n  const { x, y } = points;\n  let data = [];\n  for (let i = 0; i < x.length; i++) {\n    data.push({ x: x[i], y: y[i] });\n  }\n  return data;\n}\n\nconst XY = {\n  check,\n  integral,\n  integration,\n  maxY,\n  maximaY,\n  maxYPoint,\n  minimaY,\n  minYPoint,\n  reduce,\n  growingX,\n  minClosestYPoint,\n  maxClosestYPoint,\n  realMaxYPoint,\n  realMinYPoint,\n  peakInfo,\n  toXYObject,\n};\n\n/**\n * This function make a zero filling to re and im part.\n * @param {object} data Object of kind {x:[], re:[], im:[]}.\n * @param {number} zeroFilling - final number of points\n * @return {SD}\n */\nfunction zeroFilling(data, zeroFilling) {\n  let length = data.x.length;\n  if (zeroFilling === 0 || length === zeroFilling) return data;\n\n  if (length > zeroFilling) {\n    return {\n      x: data.x.slice(0, zeroFilling),\n      re: data.re.slice(0, zeroFilling),\n      im: data.im.slice(0, zeroFilling),\n    };\n  }\n\n  const x = data.x;\n  const re = data.re;\n  const im = data.im;\n\n  const newX = new Float64Array(zeroFilling);\n  const newRE = new Float64Array(zeroFilling);\n  const newIM = new Float64Array(zeroFilling);\n\n  for (let i = 0; i < length; i++) {\n    newX[i] = x[i];\n    newRE[i] = re[i];\n    newIM[i] = im[i];\n  }\n  const deltaX = (x[x.length - 1] - x[0]) / (length - 1);\n  for (let i = length; i < zeroFilling; i++) {\n    newX[i] = newX[i - 1] + deltaX;\n  }\n\n  return {\n    x: newX,\n    re: newRE,\n    im: newIM,\n  };\n}\n\n/**\n * Sort object of array, x has to be monotone.\n * @param {object} data Object of kind {x:[], re:[], im:[]}.\n * @return {SD}\n */\n\nfunction sortX(data) {\n  const { x, re, im } = data;\n\n  if (x.length !== re.length || x.length !== im.length) {\n    throw TypeError('sortX: length of x, re and im must be identical');\n  }\n\n  if (x.length < 2 || x[0] < x[1]) return data;\n\n  return {\n    x: x.slice(0).reverse(),\n    re: re.slice(0).reverse(),\n    im: im.slice(0).reverse(),\n  };\n}\n\nconst XReIm = {\n  zeroFilling,\n  sortX,\n};\n\n/**\n * Calculate absolute value of a spectrum\n * @param {object} reim - An object of kind {re:[], im:[]}\n * @return {Float64Array}\n */\nfunction absolute(data) {\n  const length = data.re.length;\n  const re = data.re;\n  const im = data.im;\n  const newArray = new Float64Array(length);\n  for (let i = 0; i < length; i++) {\n    newArray[i] = Math.sqrt(re[i] ** 2 + im[i] ** 2);\n  }\n\n  return newArray;\n}\n\n/**\n * Phase correction filter\n * @param {object} reim - An object of kind {re:[], im:[]}\n * @param {number} [phi0 = 0] - Angle in radians for zero order phase correction\n * @param {number} [phi1 = 0] - Angle in radians for first order phase correction\n * @return {object} returns a new object {re:[], im:[]}\n */\nfunction phaseCorrection(data, phi0, phi1) {\n  phi0 = Number.isFinite(phi0) ? phi0 : 0;\n  phi1 = Number.isFinite(phi1) ? phi1 : 0;\n\n  const re = data.re;\n  const im = data.im;\n  const length = data.re.length;\n\n  const delta = phi1 / length;\n  const alpha = 2 * Math.pow(Math.sin(delta / 2), 2);\n  const beta = Math.sin(delta);\n  let cosTheta = Math.cos(phi0);\n  let sinTheta = Math.sin(phi0);\n\n  const newRe = new Float64Array(length);\n  const newIm = new Float64Array(length);\n  for (let i = 0; i < length; i++) {\n    newRe[i] = re[i] * cosTheta - im[i] * sinTheta;\n    newIm[i] = re[i] * sinTheta + im[i] * cosTheta;\n    // calculate angles i+1 from i\n    cosTheta = cosTheta - (alpha * cosTheta + beta * sinTheta);\n    sinTheta = sinTheta - (alpha * sinTheta - beta * cosTheta);\n  }\n\n  return { re: newRe, im: newIm };\n}\n\nconst ReIm = {\n  absolute,\n  phaseCorrection,\n};\n\n/**\n\n/**\n * This function add the first array by the second array or a constant value to each element of the first array\n * @param {Array} array1 - the array that will be rotated\n * @param {Array|Number} array2\n * @return {Array}\n */\nfunction add(array1, array2) {\n  let isConstant = false;\n  let constant;\n  if (Array.isArray(array2)) {\n    if (array1.length !== array2.length) {\n      throw new Error('sub: size of array1 and array2 must be identical');\n    }\n  } else {\n    isConstant = true;\n    constant = Number(array2);\n  }\n\n  let array3 = new Array(array1.length);\n  if (isConstant) {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] + constant;\n    }\n  } else {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] + array2[i];\n    }\n  }\n\n  return array3;\n}\n\n/**\n * This function subtract the first array by the second array or a constant value from each element of the first array\n * @param {Array} array1 - the array that will be rotated\n * @return {object}\n */\nfunction boxPlot(array) {\n  array = array.slice(0).sort((a, b) => a - b);\n  if (array.length < 5) {\n    throw Error(\n      'boxPlot: can not calculate info if array contains less than 3 elements',\n    );\n  }\n  let info = {\n    Q1: 0.0,\n    Q2: 0.0,\n    Q3: 0.0,\n    min: array[0],\n    max: array[array.length - 1],\n  };\n  let q1max, q3min;\n  if (array.length % 2 === 1) {\n    // odd\n    let middle = (array.length - 1) / 2;\n    info.Q2 = array[middle];\n    q1max = middle - 1;\n    q3min = middle + 1;\n  } else {\n    // even\n    q3min = array.length / 2;\n    q1max = q3min - 1;\n    info.Q2 = (array[q1max] + array[q3min]) / 2;\n  }\n  if (q1max % 2 === 0) {\n    info.Q1 = array[q1max / 2];\n    info.Q3 = array[(array.length + q3min - 1) / 2];\n  } else {\n    info.Q1 = (array[(q1max + 1) / 2] + array[(q1max - 1) / 2]) / 2;\n    let middleOver = (array.length + q3min) / 2;\n    info.Q3 = (array[middleOver] + array[middleOver - 1]) / 2;\n  }\n  return info;\n}\n\n/**\n\n/**\n * This function multiply the first array by the second array or a constant value to each element of the first array\n * @param {Array} array1 - the array that will be rotated\n * @param {Array|Number} array2\n * @return {Float64Array}\n */\nfunction multiply(array1, array2) {\n  let isConstant = false;\n  let constant;\n  if (Array.isArray(array2)) {\n    if (array1.length !== array2.length) {\n      throw new Error('sub: size of array1 and array2 must be identical');\n    }\n  } else {\n    isConstant = true;\n    constant = Number(array2);\n  }\n\n  let array3 = new Float64Array(array1.length);\n  if (isConstant) {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] * constant;\n    }\n  } else {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] * array2[i];\n    }\n  }\n\n  return array3;\n}\n\nfunction dotProduct(A, B) {\n  let g = multiply(A, B);\n  let result = 0;\n  for (let i = 0; i < A.length; i++) {\n    result += g[i];\n  }\n  return result;\n}\n\n/**\n * Calculates the cross-correlation between 2 vectors\n * @param {Array} [A] - the array that will be fixed\n * @param {Array} [B]\n * @param {object} [options={}]\n * @param {number} [options.tau = 1]\n * @param {number} [options.lag = A.length - 1]\n */\n\nfunction crossCorrelation(A, B, options = {}) {\n  let { tau = 1, lag = A.length - 1 } = options;\n  let result = new Float64Array(1 + (2 * lag) / tau);\n  if (A.length === B.length) {\n    let n = B.length;\n    let g = new Float64Array(2 * n);\n    let q = new Float64Array(2 * n);\n    for (let i = 0; i < n; i++) {\n      q[n + i] = B[i];\n    }\n    for (let i = n * 2 - (tau - 1); i > 0; i -= tau) {\n      let k = 0;\n      for (let j = i; j < n * 2; j++) {\n        g[k] = q[j];\n        k++;\n      }\n      let w = [];\n      for (let l = 0; l < n; l++) {\n        w[l] = g[l];\n      }\n      result[(k - (n - lag)) / tau] = dotProduct(A, w);\n    }\n  }\n  return result;\n}\n\n/**\n * Calculates the auto-correlation of a vector\n * @param {Array} [A] - the array that will be fixed\n * @param {object} [options={}]\n * @param {number} [options.tau = 1]\n * @param {number} [options.lag = A.length - 1]\n */\n\nfunction autoCorrelation(A, options = {}) {\n  return crossCorrelation(A, A, options);\n}\n\n/**\n\n/**\n * Calculates the correlation between 2 vectors\n * https://en.wikipedia.org/wiki/Correlation_and_dependence\n *\n * @param {Array} [A] - the array that will be rotated\n * @param {Array} [B]\n * @return {Array}\n */\nfunction correlation(A, B) {\n  let n = A.length;\n  let sumA = 0;\n  let sumA2 = 0;\n  let sumB = 0;\n  let sumB2 = 0;\n  let sumAB = 0;\n  for (let i = 0; i < n; i++) {\n    let a = A[i];\n    let b = B[i];\n    sumA += a;\n    sumA2 += a ** 2;\n    sumB += b;\n    sumB2 += b ** 2;\n    sumAB += a * b;\n  }\n  return (\n    (n * sumAB - sumA * sumB) /\n    (Math.sqrt(n * sumA2 - sumA ** 2) * Math.sqrt(n * sumB2 - sumB ** 2))\n  );\n}\n\n/**\n\n/**\n * This function divide the first array by the second array or a constant value to each element of the first array\n * @param {Array} array1 - the array that will be rotated\n * @param {Array|Number} array2\n * @return {Array}\n */\nfunction divide(array1, array2) {\n  let isConstant = false;\n  let constant;\n  if (Array.isArray(array2)) {\n    if (array1.length !== array2.length) {\n      throw new Error('sub: size of array1 and array2 must be identical');\n    }\n  } else {\n    isConstant = true;\n    constant = Number(array2);\n  }\n\n  let array3 = new Array(array1.length);\n  if (isConstant) {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] / constant;\n    }\n  } else {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] / array2[i];\n    }\n  }\n\n  return array3;\n}\n\n/**\n * This function performs a circular shift to a new array\n * Positive values of shifts will shift to the right and negative values will do to the left\n * @example rotate([1,2,3,4],1) -> [4,1,2,3]\n * @example rotate([1,2,3,4],-1) -> [2,3,4,1]\n * @param {Array} array - the array that will be rotated\n * @param {number} shift\n * @return {Array}\n */\nfunction rotate(array, shift) {\n  shift = shift % array.length;\n  if (shift < 0) shift += array.length;\n  return array\n    .slice(array.length - shift)\n    .concat(array.slice(0, array.length - shift));\n}\n\n/**\n * This function subtract the first array by the second array or a constant value from each element of the first array\n * @param {Array} array1 - the array that will be rotated\n * @param {Array|Number} array2\n * @return {Array}\n */\nfunction subtract(array1, array2) {\n  let isConstant = false;\n  let constant;\n  if (Array.isArray(array2)) {\n    if (array1.length !== array2.length) {\n      throw new Error('sub: size of array1 and array2 must be identical');\n    }\n  } else {\n    isConstant = true;\n    constant = Number(array2);\n  }\n\n  let array3 = new Array(array1.length);\n  if (isConstant) {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] - constant;\n    }\n  } else {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] - array2[i];\n    }\n  }\n\n  return array3;\n}\n\nconst X = {\n  add,\n  autoCorrelation,\n  boxPlot,\n  correlation,\n  crossCorrelation,\n  divide,\n  findClosestIndex,\n  getFromToIndex,\n  getTargetIndex,\n  multiply,\n  rotate,\n  subtract,\n};\n\n/**\n *\n * @param {array} [data] array of growing points {x,y}\n * @param {object} [options={}]\n * @param {object} [xError=Number.EPSILON] limit to join the data\n */\nfunction joinX(data, options = {}) {\n  const { xError = Number.EPSILON } = options;\n\n  // when we join we will use the center of mass\n  let result = [];\n  let current = {\n    x: Number.MIN_SAFE_INTEGER,\n    y: 0,\n  };\n  for (let item of data) {\n    if (item.x - current.x <= xError) {\n      // weighted sum\n      current.x =\n        (item.y / (current.y + item.y)) * (item.x - current.x) + current.x;\n      current.y += item.y;\n    } else {\n      current = {\n        x: item.x,\n        y: item.y,\n      };\n      result.push(current);\n    }\n  }\n  return result;\n}\n\n/**\n *\n * @param {array} [data] array of growing points {x,y}\n * @param {object} [options={}]\n * @param {object} [slotWidth=1] limit to join the data\n */\nfunction slotX(data, options = {}) {\n  const { slotWidth = 1 } = options;\n  const halfSlot = slotWidth / 2;\n\n  // when we join we will use the center of mass\n  let result = [];\n  let current = {\n    x: Number.MIN_VALUE,\n    y: 0,\n  };\n  for (let item of data) {\n    let slot = item.x - ((item.x + halfSlot) % slotWidth) + halfSlot;\n    if (Math.abs(current.x - slot) > Number.EPSILON) {\n      current = {\n        x: slot,\n        y: 0,\n      };\n      result.push(current);\n    }\n    current.y += item.y;\n  }\n  return result;\n}\n\n/**\n * Sorts an array of points\n * @param {array} [data] array of points {x,y}\n */\n\nfunction sortX$1(data) {\n  return data.sort((a, b) => a.x - b.x);\n}\n\n/**\n *\n * @param {array} [data] array of points {x,y}\n */\nfunction toXY(data) {\n  return {\n    x: data.map((entry) => entry.x),\n    y: data.map((entry) => entry.y),\n  };\n}\n\nconst XYObject = {\n  joinX,\n  slotX,\n  sortX: sortX$1,\n  toXY,\n};\n\nexports.ReIm = ReIm;\nexports.X = X;\nexports.XReIm = XReIm;\nexports.XY = XY;\nexports.XYObject = XYObject;\n"],"names":["toString","Object","prototype","object","call","endsWith","check","points","isAnyArray","x","y","Error","length","findClosestIndex","array","target","low","high","middle","Math","abs","getFromToIndex","options","fromIndex","toIndex","from","to","undefined","getTargetIndex","targetIndex","defineProperty","exports","value","XY","integral","reverse","integration","i","push","maxY","maximaY","maxima","startEqualIndex","index","maxYPoint","current","minimaY","minYPoint","reduce","nbPoints","optimize","slice","newX","newY","minY","Number","MAX_VALUE","MIN_VALUE","slot","currentX","first","growingX","data","TypeError","minClosestYPoint","previousIndex","MIN_SAFE_INTEGER","currentIndex","maxClosestYPoint","realMaxYPoint","alpha","log10","beta","gamma","p","realMinYPoint","peakInfo","currentDiff","multiplier","newDiff","after","before","inflectionBefore","inflectionAfter","extrema","inflectionMiddle","width","toXYObject","XReIm","zeroFilling","re","im","Float64Array","newRE","newIM","deltaX","sortX","ReIm","absolute","newArray","sqrt","phaseCorrection","phi0","phi1","isFinite","delta","pow","sin","cosTheta","cos","sinTheta","newRe","newIm","multiply","array1","array2","constant","isConstant","Array","isArray","array3","dotProduct","A","B","g","result","crossCorrelation","tau","lag","n","q","k","j","w","l","X","add","autoCorrelation","boxPlot","sort","a","b","q1max","q3min","info","Q1","Q2","Q3","min","max","middleOver","correlation","sumA","sumA2","sumB","sumB2","sumAB","divide","rotate","shift","concat","subtract","XYObject","joinX","xError","EPSILON","item","slotX","slotWidth","halfSlot","toXY","map","entry"],"mappings":"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"}