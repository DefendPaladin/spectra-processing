{"version":3,"file":"ml-spectra-processing.min.js","sources":["../node_modules/is-any-array/src/index.js","../lib/index.js"],"sourcesContent":["'use strict';\n\nconst toString = Object.prototype.toString;\n\nfunction isAnyArray(object) {\n  return toString.call(object).endsWith('Array]');\n}\n\nmodule.exports = isAnyArray;\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst isAnyArray = require('is-any-array');\n\n/**\n * Throw an error in no an object of x,y arrays\n * @param {object} [points={}]\n */\nfunction check(points = {}) {\n  if (!isAnyArray(points.x) || !isAnyArray(points.y)) {\n    throw new Error('Points must be an object of x and y arrays');\n  }\n  if (points.x.length !== points.y.length) {\n    throw new Error('The x and y arrays mush have the same length');\n  }\n}\n\n/**\n * Returns the closest index of a `target` in an ordered array\n * @param {array} array\n * @param {number} target\n */\n\nfunction findClosestIndex(array, target) {\n  let low = 0;\n  let high = array.length - 1;\n  let middle = 0;\n  while (high - low > 1) {\n    middle = low + ((high - low) >> 1);\n    if (array[middle] < target) {\n      low = middle;\n    } else if (array[middle] > target) {\n      high = middle;\n    } else {\n      return middle;\n    }\n  }\n\n  if (low < array.length - 1) {\n    if (Math.abs(target - array[low]) < Math.abs(array[low + 1] - target)) {\n      return low;\n    } else {\n      return low + 1;\n    }\n  } else {\n    return low;\n  }\n}\n\n/**\n * Returns an object with {fromIndex, toIndex} for a specific from / to\n * @param {array} x\n * @param {object} [options={}]\n * @param {number} [options.from] - First value for integration in the X scale\n * @param {number} [options.fromIndex=0] - First point for integration\n * @param {number} [options.to] - Last value for integration in the X scale\n * @param {number} [options.toIndex=x.length-1] - Last point for integration\n */\n\nfunction getFromToIndex(x, options = {}) {\n  let { fromIndex, toIndex, from, to } = options;\n\n  if (fromIndex === undefined) {\n    if (from !== undefined) {\n      fromIndex = findClosestIndex(x, from);\n    } else {\n      fromIndex = 0;\n    }\n  }\n  if (toIndex === undefined) {\n    if (to !== undefined) {\n      toIndex = findClosestIndex(x, to);\n    } else {\n      toIndex = x.length - 1;\n    }\n  }\n  return { fromIndex, toIndex };\n}\n\n/**\n * In place modification of the 2 arrays to make X unique and sum the Y if X has the same value\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.from] - First value for integration in the X scale\n * @param {number} [options.fromIndex=0] - First point for integration\n * @param {number} [options.to] - Last value for integration in the X scale\n * @param {number} [options.toIndex=x.length-1] - Last point for integration\n * @return {number} Integration value on the specified range\n */\n\nfunction integration(points = {}, options = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 2) return 0;\n  const { fromIndex, toIndex } = getFromToIndex(x, options);\n  let integration = 0;\n  for (let i = fromIndex; i < toIndex; i++) {\n    integration += ((x[i + 1] - x[i]) * (y[i + 1] + y[i])) / 2;\n  }\n\n  return integration;\n}\n\n/**\n * Generate a X / Y of the integral\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.from] - First value for integration in the X scale\n * @param {number} [options.fromIndex=0] - First point for integration\n * @param {number} [options.to] - Last value for integration in the X scale\n * @param {number} [options.toIndex=x.length-1] - Last point for integration\n * @param {boolean} [options.reverse=false] - Integrate from the larger value to the smallest value\n * @return {{x:[],y:[]}} An object with the integration function\n */\n\nfunction integral(points = {}, options = {}) {\n  const { reverse = false } = options;\n  check(points);\n  const { x, y } = points;\n  if (x.length < 2) return 0;\n\n  const { fromIndex, toIndex } = getFromToIndex(x, options);\n\n  let integration = 0;\n  let integral;\n  if (reverse) {\n    integral = { x: [x[toIndex]], y: [0] };\n    for (let i = toIndex; i > fromIndex; i--) {\n      integration += ((x[i] - x[i - 1]) * (y[i - 1] + y[i])) / 2;\n      integral.x.push(x[i - 1]);\n      integral.y.push(integration);\n    }\n    integral.x.reverse();\n    integral.y.reverse();\n  } else {\n    integral = { x: [x[fromIndex]], y: [0] };\n    for (let i = fromIndex; i < toIndex; i++) {\n      integration += ((x[i + 1] - x[i]) * (y[i + 1] + y[i])) / 2;\n      integral.x.push(x[i + 1]);\n      integral.y.push(integration);\n    }\n  }\n\n  return integral;\n}\n\n/**\n * Finds the max value in a zone\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.from] - First value for integration in the X scale\n * @param {number} [options.fromIndex=0] - First point for integration\n * @param {number} [options.to] - Last value for integration in the X scale\n * @param {number} [options.toIndex=x.length-1] - Last point for integration\n * @return {number} Max y on the specified range\n */\n\nfunction maxY(points = {}, options = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 2) return 0;\n\n  const { fromIndex, toIndex } = getFromToIndex(x, options);\n\n  let maxY = y[fromIndex];\n  for (let i = fromIndex; i <= toIndex; i++) {\n    if (y[i] > maxY) maxY = y[i];\n  }\n\n  return maxY;\n}\n\n/**\n * Finds the max y value in a range and return a {x,y} point\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.from] - First value for integration in the X scale\n * @param {number} [options.fromIndex=0] - First point for integration\n * @param {number} [options.to] - Last value for integration in the X scale\n * @param {number} [options.toIndex=x.length-1] - Last point for integration\n * @return {object}\n */\n\nfunction maxYPoint(points = {}, options = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 2) return 0;\n\n  const { fromIndex, toIndex } = getFromToIndex(x, options);\n\n  let current = { x: x[fromIndex], y: y[fromIndex] };\n  for (let i = fromIndex; i <= toIndex; i++) {\n    if (y[i] > current.y) current = { x: x[i], y: y[i] };\n  }\n\n  return current;\n}\n\n/**\n * Finds the max y value in a range and return a {x,y} point\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.from] - First value for integration in the X scale\n * @param {number} [options.fromIndex=0] - First point for integration\n * @param {number} [options.to] - Last value for integration in the X scale\n * @param {number} [options.toIndex=x.length-1] - Last point for integration\n * @return {object}\n */\n\nfunction minYPoint(points = {}, options = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 2) return 0;\n\n  const { fromIndex, toIndex } = getFromToIndex(x, options);\n\n  let current = { x: x[fromIndex], y: y[fromIndex] };\n  for (let i = fromIndex; i <= toIndex; i++) {\n    if (y[i] < current.y) current = { x: x[i], y: y[i] };\n  }\n\n  return current;\n}\n\n/**\n * Reduce the number of points while keeping the same noise. Practical to\n * display many spectra as SVG\n * @param {array} x\n * @param {array} y\n * @param {object} [options={}]\n * @param {number} [from=x[0]]\n * @param {number} [to=x[x.length-1]]\n * @param {number} [nbPoints=4001] Number of points\n */\n\nfunction reduce(x, y, options = {}) {\n  let { from = x[0], to = x[x.length - 1], nbPoints = 4000 } = options;\n\n  let fromIndex = findClosestIndex(x, from);\n  let toIndex = findClosestIndex(x, to);\n\n  if (fromIndex > 0 && x[fromIndex] > from) fromIndex--;\n  if (toIndex < x.length - 1 && x[toIndex] < to) toIndex++;\n\n  if (toIndex - fromIndex < nbPoints) {\n    return {\n      x: x.slice(fromIndex, toIndex + 1),\n      y: y.slice(fromIndex, toIndex + 1),\n    };\n  }\n\n  let newX = [x[fromIndex]];\n  let newY = [y[fromIndex]];\n  let minY = Number.MAX_VALUE;\n  let maxY = Number.MIN_VALUE;\n  if (nbPoints % 2 === 0) {\n    nbPoints = nbPoints / 2 + 1;\n  } else {\n    nbPoints = (nbPoints - 1) / 2 + 1;\n  }\n\n  let slot = (x[toIndex] - x[fromIndex]) / (nbPoints - 1);\n  let currentX = x[fromIndex] + slot;\n  let first = true;\n  for (let i = fromIndex + 1; i <= toIndex; i++) {\n    if (first) {\n      minY = y[i];\n      maxY = y[i];\n      first = false;\n    } else {\n      if (y[i] < minY) minY = y[i];\n      if (y[i] > maxY) maxY = y[i];\n    }\n\n    if (x[i] >= currentX || i === toIndex) {\n      newX.push(currentX - slot / 2);\n      newY.push(minY);\n      newX.push(currentX);\n      newY.push(maxY);\n      currentX += slot;\n      first = true;\n    }\n  }\n\n  // we will need to make some kind of min / max because there are too many points\n  // we will always keep the first point and the last point\n\n  return { x: newX, y: newY };\n}\n\n/**\n * Sort object of array, x has to be monotone.\n * @param {object} data Object of kind {x:[], re:[], im:[]}.\n * @return {SD}\n */\n\nfunction sortX(data) {\n  const { x, y } = data;\n\n  if (x.length !== y.length) {\n    throw TypeError('sortX: length of x and y must be identical');\n  }\n\n  if (x.length < 2 || x[0] < x[1]) return data;\n\n  return {\n    x: x.slice(0).reverse(),\n    y: y.slice(0).reverse(),\n  };\n}\n\n/**\n * Find the closest minimum going down hill\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.target]\n * @param {number} [options.targetIndex=0]\n * @return {{x,y,xIndex}} An object with the x/y value\n */\n\nfunction minClosestYPoint(points, options = {}) {\n  check(points);\n  const { x, y } = points;\n\n  let { target, targetIndex } = options;\n\n  if (targetIndex === undefined) {\n    if (target !== undefined) {\n      targetIndex = findClosestIndex(x, target);\n    } else {\n      targetIndex = 0;\n    }\n  }\n\n  let previousIndex = Number.MIN_SAFE_INTEGER;\n  let currentIndex = targetIndex;\n\n  let minY = y[targetIndex];\n\n  while (currentIndex !== previousIndex) {\n    previousIndex = currentIndex;\n    if (currentIndex > 0 && y[currentIndex - 1] < minY) {\n      currentIndex--;\n    } else if (currentIndex < x.length - 1 && y[currentIndex + 1] < minY) {\n      currentIndex++;\n    }\n    minY = y[currentIndex];\n  }\n  return {\n    x: x[currentIndex],\n    y: y[currentIndex],\n    index: currentIndex,\n  };\n}\n\n/**\n * Find the closest maximum going up hill\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.target]\n * @param {number} [options.targetIndex=0]\n * @return {{x,y,xIndex}} An object with the x/y value\n */\n\nfunction maxClosestYPoint(points, options = {}) {\n  check(points);\n  const { x, y } = points;\n\n  let { target, targetIndex } = options;\n\n  if (targetIndex === undefined) {\n    if (target !== undefined) {\n      targetIndex = findClosestIndex(x, target);\n    } else {\n      targetIndex = 0;\n    }\n  }\n\n  let previousIndex = Number.MIN_SAFE_INTEGER;\n  let currentIndex = targetIndex;\n\n  let maxY = y[targetIndex];\n\n  while (currentIndex !== previousIndex) {\n    previousIndex = currentIndex;\n    if (currentIndex > 0 && y[currentIndex - 1] > maxY) {\n      currentIndex--;\n    } else if (currentIndex < x.length - 1 && y[currentIndex + 1] > maxY) {\n      currentIndex++;\n    }\n    maxY = y[currentIndex];\n  }\n  return {\n    x: x[currentIndex],\n    y: y[currentIndex],\n    index: currentIndex,\n  };\n}\n\n/**\n *  Returns the targetIndex\n * @param {array} [x]\n * @param {object} [options={}]\n * @param {number} [options.target]\n * @param {number} [options.targetIndex=0]\n * @param {number}\n */\n\nfunction getTargetIndex(x, options = {}) {\n  let { target, targetIndex } = options;\n  if (targetIndex === undefined) {\n    if (target !== undefined) {\n      return findClosestIndex(x, target);\n    } else {\n      return 0;\n    }\n  }\n  return targetIndex;\n}\n\nfunction realMinYPoint(points, options = {}) {\n  check(points);\n  const { x, y } = points;\n\n  const targetIndex = getTargetIndex(x, options);\n  // interpolation to a sin() function\n  if (\n    y[targetIndex - 1] < 0 &&\n    y[targetIndex + 1] < 0 &&\n    y[targetIndex] <= y[targetIndex - 1] &&\n    y[targetIndex] <= y[targetIndex + 1]\n  ) {\n    let alpha = 20 * Math.log10(-y[targetIndex - 1]);\n    let beta = 20 * Math.log10(-y[targetIndex]);\n    let gamma = 20 * Math.log10(-y[targetIndex + 1]);\n    let p = (0.5 * (alpha - gamma)) / (alpha - 2 * beta + gamma);\n    return {\n      x: x[targetIndex] + (x[targetIndex] - x[targetIndex - 1]) * p,\n      y: y[targetIndex] - 0.25 * (y[targetIndex - 1] - y[targetIndex + 1]) * p,\n      index: targetIndex,\n    };\n  } else {\n    return {\n      x: x[targetIndex],\n      y: y[targetIndex],\n      index: targetIndex,\n    };\n  }\n}\n\n/**\n * Find the closest minimum going down hill\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.target]\n * @param {number} [options.targetIndex=0]\n * @return {{x,y,xIndex}} An object with the x/y value\n */\n\nfunction realMaxYPoint(points, options = {}) {\n  check(points);\n  const { x, y } = points;\n  const targetIndex = getTargetIndex(x, options);\n  // interpolation to a sin() function\n  if (\n    y[targetIndex - 1] > 0 &&\n    y[targetIndex + 1] > 0 &&\n    y[targetIndex] >= y[targetIndex - 1] &&\n    y[targetIndex] >= y[targetIndex + 1]\n  ) {\n    let alpha = 20 * Math.log10(y[targetIndex - 1]);\n    let beta = 20 * Math.log10(y[targetIndex]);\n    let gamma = 20 * Math.log10(y[targetIndex + 1]);\n    let p = (0.5 * (alpha - gamma)) / (alpha - 2 * beta + gamma);\n    return {\n      x: x[targetIndex] + (x[targetIndex] - x[targetIndex - 1]) * p,\n      y: y[targetIndex] - 0.25 * (y[targetIndex - 1] - y[targetIndex + 1]) * p,\n      index: targetIndex,\n    };\n  } else {\n    return {\n      x: x[targetIndex],\n      y: y[targetIndex],\n      index: targetIndex,\n    };\n  }\n}\n\n/**\n * Finds all the max values\n * If the values are equal the middle\n * of the equal part will be the position of the signal!\n *\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @return {Array} Array of points\n */\n\nfunction maximaY(points = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 3) return [];\n  let maxima = [];\n  let startEqualIndex = -1;\n  for (let i = 1; i < x.length - 1; i++) {\n    if (y[i - 1] < y[i] && y[i + 1] < y[i]) {\n      maxima.push({ x: x[i], y: y[i], index: i });\n    } else if (y[i - 1] < y[i] && y[i + 1] === y[i]) {\n      startEqualIndex = i;\n    } else if (y[i - 1] === y[i] && y[i + 1] < y[i]) {\n      let index = ((i + startEqualIndex) / 2) >> 0;\n      maxima.push({ x: x[index], y: y[index], index });\n    }\n  }\n  return maxima;\n}\n\n/**\n * Finds all the min values\n * If the values are equal the middle\n * of the equal part will be the position of the signal!\n *\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @return {Array} Array of points\n */\n\nfunction minimaY(points = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 3) return [];\n  let maxima = [];\n  let startEqualIndex = -1;\n  for (let i = 1; i < x.length - 1; i++) {\n    if (y[i - 1] > y[i] && y[i + 1] > y[i]) {\n      maxima.push({ x: x[i], y: y[i], index: i });\n    } else if (y[i - 1] > y[i] && y[i + 1] === y[i]) {\n      startEqualIndex = i;\n    } else if (y[i - 1] === y[i] && y[i + 1] > y[i]) {\n      let index = ((i + startEqualIndex) / 2) >> 0;\n      maxima.push({ x: x[index], y: y[index], index });\n    }\n  }\n  return maxima;\n}\n\n/**\n * Returns an information about a signal\n *\n * We expect ordered data and equidistant X axis\n * You can use the method helper if required:\n * ML.ArrayXY.uniqueX\n * ML.ArrayXY.sortX\n * ML.ArrayXY.equallySpaced\n *\n * @param {object} [points={}] - Object of points contains property x (an ordered increasing array) and y (an array)\n * @param {object} [options={}]\n * @param {number} [options.target]\n * @param {number} [options.targetIndex]\n * @return {object} Information about signal\n */\n\nfunction peakInfo(points = {}, options = {}) {\n  check(points);\n  const { x, y } = points;\n  if (x.length < 3) return undefined;\n  let { targetIndex, target } = options;\n  if (targetIndex === undefined) {\n    if (target !== undefined) {\n      targetIndex = findClosestIndex(x, target);\n    }\n  }\n\n  if (targetIndex === undefined) {\n    throw new Error('peakInfo: need to specify target or targetIndex');\n  }\n\n  let i = targetIndex;\n  let currentDiff = y[i] - y[i + 1];\n\n  let multiplier = currentDiff < 0 ? -1 : 1;\n  currentDiff *= multiplier;\n  while (i < x.length - 1) {\n    i++;\n    let newDiff = (y[i] - y[i + 1]) * multiplier;\n    if (newDiff < currentDiff) break;\n    currentDiff = newDiff;\n  }\n  let after = { x: x[i], y: y[i] };\n\n  i = targetIndex;\n  currentDiff = (y[i] - y[i - 1]) * multiplier;\n  while (i > 1) {\n    i--;\n    let newDiff = (y[i] - y[i - 1]) * multiplier;\n    if (newDiff < currentDiff) break;\n    currentDiff = newDiff;\n  }\n  let before = { x: x[i], y: y[i] };\n\n  return {\n    inflectionBefore: before,\n    inflectionAfter: after,\n    extrema: { x: x[targetIndex], y: y[targetIndex] },\n    inflectionMiddle: {\n      x: (before.x + after.x) / 2,\n      y: (before.y + after.y) / 2,\n    },\n    width: Math.abs(before.x - after.x),\n  };\n}\n\nconst XY = {\n  check,\n  integral,\n  integration,\n  maxY,\n  maximaY,\n  maxYPoint,\n  minimaY,\n  minYPoint,\n  reduce,\n  sortX,\n  minClosestYPoint,\n  maxClosestYPoint,\n  realMaxYPoint,\n  realMinYPoint,\n  peakInfo,\n};\n\n/**\n * This function make a zero filling to re and im part.\n * @param {object} data Object of kind {x:[], re:[], im:[]}.\n * @param {number} zeroFilling - final number of points\n * @return {SD}\n */\nfunction zeroFilling(data, zeroFilling) {\n  let length = data.x.length;\n  if (zeroFilling === 0 || length === zeroFilling) return data;\n\n  if (length > zeroFilling) {\n    return {\n      x: data.x.slice(0, zeroFilling),\n      re: data.re.slice(0, zeroFilling),\n      im: data.im.slice(0, zeroFilling),\n    };\n  }\n\n  const x = data.x;\n  const re = data.re;\n  const im = data.im;\n\n  const newX = new Float64Array(zeroFilling);\n  const newRE = new Float64Array(zeroFilling);\n  const newIM = new Float64Array(zeroFilling);\n\n  for (let i = 0; i < length; i++) {\n    newX[i] = x[i];\n    newRE[i] = re[i];\n    newIM[i] = im[i];\n  }\n  const deltaX = (x[x.length - 1] - x[0]) / (length - 1);\n  for (let i = length; i < zeroFilling; i++) {\n    newX[i] = newX[i - 1] + deltaX;\n  }\n\n  return {\n    x: newX,\n    re: newRE,\n    im: newIM,\n  };\n}\n\n/**\n * Sort object of array, x has to be monotone.\n * @param {object} data Object of kind {x:[], re:[], im:[]}.\n * @return {SD}\n */\n\nfunction sortX$1(data) {\n  const { x, re, im } = data;\n\n  if (x.length !== re.length || x.length !== im.length) {\n    throw TypeError('sortX: length of x, re and im must be identical');\n  }\n\n  if (x.length < 2 || x[0] < x[1]) return data;\n\n  return {\n    x: x.slice(0).reverse(),\n    re: re.slice(0).reverse(),\n    im: im.slice(0).reverse(),\n  };\n}\n\nconst XReIm = {\n  zeroFilling,\n  sortX: sortX$1,\n};\n\n/**\n * Calculate absolute value of a spectrum\n * @param {object} reim - An object of kind {re:[], im:[]}\n * @return {Float64Array}\n */\nfunction absolute(data) {\n  const length = data.re.length;\n  const re = data.re;\n  const im = data.im;\n  const newArray = new Float64Array(length);\n  for (let i = 0; i < length; i++) {\n    newArray[i] = Math.sqrt(re[i] ** 2 + im[i] ** 2);\n  }\n\n  return newArray;\n}\n\n/**\n * Phase correction filter\n * @param {object} reim - An object of kind {re:[], im:[]}\n * @param {number} [phi0 = 0] - value\n * @param {number} [phi1 = 0] - value\n * @return {object} returns a new object {re:[], im:[]}\n */\nfunction phaseCorrection(data, phi0, phi1) {\n  phi0 = Number.isFinite(phi0) ? phi0 : 0;\n  phi1 = Number.isFinite(phi1) ? phi1 : 0;\n\n  const re = data.re.slice(0);\n  const im = data.im.slice(0);\n  const length = data.re.length;\n\n  const delta = phi1 / length;\n  const alpha = 2 * Math.pow(Math.sin(delta / 2), 2);\n  const beta = Math.sin(delta);\n  let cosTheta = Math.cos(phi0);\n  let sinTheta = Math.sin(phi0);\n\n  const newRe = new Float64Array(length);\n  const newIm = new Float64Array(length);\n  for (let i = 0; i < length; i++) {\n    newRe[i] = re[i] * cosTheta - im[i] * sinTheta;\n    newIm[i] = re[i] * sinTheta + im[i] * cosTheta;\n    // calculate angles i+1 from i\n    cosTheta = cosTheta - (alpha * cosTheta + beta * sinTheta);\n    sinTheta = sinTheta - (alpha * sinTheta - beta * cosTheta);\n  }\n\n  return { re: newRe, im: newIm };\n}\n\nconst ReIm = {\n  absolute,\n  phaseCorrection,\n};\n\n/**\n\n/**\n * This function add the first array by the second array or a constant value to each element of the first array\n * @param {Array} array1 - the array that will be rotated\n * @param {Array|Number} array2\n * @return {Array}\n */\nfunction add(array1, array2) {\n  let isConstant = false;\n  let constant;\n  if (Array.isArray(array2)) {\n    if (array1.length !== array2.length) {\n      throw new Error('sub: size of array1 and array2 must be identical');\n    }\n  } else {\n    isConstant = true;\n    constant = Number(array2);\n  }\n\n  let array3 = new Array(array1.length);\n  if (isConstant) {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] + constant;\n    }\n  } else {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] + array2[i];\n    }\n  }\n\n  return array3;\n}\n\n/**\n * This function subtract the first array by the second array or a constant value from each element of the first array\n * @param {Array} array1 - the array that will be rotated\n * @return {object}\n */\nfunction boxPlot(array) {\n  array = array.slice(0).sort((a, b) => a - b);\n  if (array.length < 5) {\n    throw Error(\n      'boxPlot: can not calculate info if array contains less than 3 elements',\n    );\n  }\n  let info = {\n    Q1: 0.0,\n    Q2: 0.0,\n    Q3: 0.0,\n    min: array[0],\n    max: array[array.length - 1],\n  };\n  let q1max, q3min;\n  if (array.length % 2 === 1) {\n    // odd\n    let middle = (array.length - 1) / 2;\n    info.Q2 = array[middle];\n    q1max = middle - 1;\n    q3min = middle + 1;\n  } else {\n    // even\n    q3min = array.length / 2;\n    q1max = q3min - 1;\n    info.Q2 = (array[q1max] + array[q3min]) / 2;\n  }\n  if (q1max % 2 === 0) {\n    info.Q1 = array[q1max / 2];\n    info.Q3 = array[(array.length + q3min - 1) / 2];\n  } else {\n    info.Q1 = (array[(q1max + 1) / 2] + array[(q1max - 1) / 2]) / 2;\n    let middleOver = (array.length + q3min) / 2;\n    info.Q3 = (array[middleOver] + array[middleOver - 1]) / 2;\n  }\n  return info;\n}\n\n/**\n\n/**\n * This function divide the first array by the second array or a constant value to each element of the first array\n * @param {Array} array1 - the array that will be rotated\n * @param {Array|Number} array2\n * @return {Array}\n */\nfunction divide(array1, array2) {\n  let isConstant = false;\n  let constant;\n  if (Array.isArray(array2)) {\n    if (array1.length !== array2.length) {\n      throw new Error('sub: size of array1 and array2 must be identical');\n    }\n  } else {\n    isConstant = true;\n    constant = Number(array2);\n  }\n\n  let array3 = new Array(array1.length);\n  if (isConstant) {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] / constant;\n    }\n  } else {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] / array2[i];\n    }\n  }\n\n  return array3;\n}\n\n/**\n\n/**\n * This function multiply the first array by the second array or a constant value to each element of the first array\n * @param {Array} array1 - the array that will be rotated\n * @param {Array|Number} array2\n * @return {Array}\n */\nfunction multiply(array1, array2) {\n  let isConstant = false;\n  let constant;\n  if (Array.isArray(array2)) {\n    if (array1.length !== array2.length) {\n      throw new Error('sub: size of array1 and array2 must be identical');\n    }\n  } else {\n    isConstant = true;\n    constant = Number(array2);\n  }\n\n  let array3 = new Array(array1.length);\n  if (isConstant) {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] * constant;\n    }\n  } else {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] * array2[i];\n    }\n  }\n\n  return array3;\n}\n\n/**\n * This function performs a circular shift to a new array\n * Positive values of shifts will shift to the right and negative values will do to the left\n * @example rotate([1,2,3,4],1) -> [4,1,2,3]\n * @example rotate([1,2,3,4],-1) -> [2,3,4,1]\n * @param {Array} array - the array that will be rotated\n * @param {number} shift\n * @return {Array}\n */\nfunction rotate(array, shift) {\n  shift = shift % array.length;\n  if (shift < 0) shift += array.length;\n  return array\n    .slice(array.length - shift)\n    .concat(array.slice(0, array.length - shift));\n}\n\n/**\n * This function subtract the first array by the second array or a constant value from each element of the first array\n * @param {Array} array1 - the array that will be rotated\n * @param {Array|Number} array2\n * @return {Array}\n */\nfunction subtract(array1, array2) {\n  let isConstant = false;\n  let constant;\n  if (Array.isArray(array2)) {\n    if (array1.length !== array2.length) {\n      throw new Error('sub: size of array1 and array2 must be identical');\n    }\n  } else {\n    isConstant = true;\n    constant = Number(array2);\n  }\n\n  let array3 = new Array(array1.length);\n  if (isConstant) {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] - constant;\n    }\n  } else {\n    for (let i = 0; i < array1.length; i++) {\n      array3[i] = array1[i] - array2[i];\n    }\n  }\n\n  return array3;\n}\n\n/**\n\n/**\n * Calculates the correlation between 2 vectors\n * https://en.wikipedia.org/wiki/Correlation_and_dependence\n *\n * @param {Array} [A] - the array that will be rotated\n * @param {Array} [B]\n * @return {Array}\n */\nfunction correlation(A, B) {\n  let n = A.length;\n  let sumA = 0;\n  let sumA2 = 0;\n  let sumB = 0;\n  let sumB2 = 0;\n  let sumAB = 0;\n  for (let i = 0; i < n; i++) {\n    let a = A[i];\n    let b = B[i];\n    sumA += a;\n    sumA2 += a ** 2;\n    sumB += b;\n    sumB2 += b ** 2;\n    sumAB += a * b;\n  }\n  return (\n    (n * sumAB - sumA * sumB) /\n    (Math.sqrt(n * sumA2 - sumA ** 2) * Math.sqrt(n * sumB2 - sumB ** 2))\n  );\n}\n\nconst X = {\n  add,\n  boxPlot,\n  divide,\n  findClosestIndex,\n  getTargetIndex,\n  multiply,\n  rotate,\n  subtract,\n  correlation,\n};\n\nexports.ReIm = ReIm;\nexports.X = X;\nexports.XReIm = XReIm;\nexports.XY = XY;\n"],"names":["toString","Object","prototype","object","call","endsWith","check","points","isAnyArray","x","y","Error","length","findClosestIndex","array","target","low","high","middle","Math","abs","getFromToIndex","options","fromIndex","toIndex","from","to","undefined","getTargetIndex","targetIndex","defineProperty","exports","value","XY","integral","reverse","integration","i","push","maxY","maximaY","maxima","startEqualIndex","index","maxYPoint","current","minimaY","minYPoint","reduce","nbPoints","slice","newX","newY","minY","Number","MAX_VALUE","MIN_VALUE","slot","currentX","first","sortX","data","TypeError","minClosestYPoint","previousIndex","MIN_SAFE_INTEGER","currentIndex","maxClosestYPoint","realMaxYPoint","alpha","log10","beta","gamma","p","realMinYPoint","peakInfo","currentDiff","multiplier","newDiff","after","before","inflectionBefore","inflectionAfter","extrema","inflectionMiddle","width","XReIm","zeroFilling","re","im","Float64Array","newRE","newIM","deltaX","ReIm","absolute","newArray","sqrt","phaseCorrection","phi0","phi1","isFinite","delta","pow","sin","cosTheta","cos","sinTheta","newRe","newIm","X","add","array1","array2","constant","isConstant","Array","isArray","array3","boxPlot","sort","a","b","q1max","q3min","info","Q1","Q2","Q3","min","max","middleOver","divide","multiply","rotate","shift","concat","subtract","correlation","A","B","n","sumA","sumA2","sumB","sumB2","sumAB"],"mappings":"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"}